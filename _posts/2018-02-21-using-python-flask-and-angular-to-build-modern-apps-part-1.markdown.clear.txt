---
layout: post
title: "Using Python, Flask, and Angular to Build Modern Web Apps - Part 1"
description: "In this series, you will learn how to create modern web applications with Python, Flask, and Angular."
longdescription: "In this series, you will learn how to create modern web applications with Python, Flask, and Angular. You will create a SPA and a backend API to expose exams and questions so users can test their knowledge regarding different technologies."
date: 2018-02-21 08:30
category: Technical Guide, Python
author:
  name: "Bruno Krebs"
  url: "https://twitter.com/brunoskrebs"
  mail: "bruno.krebs@gmail.com"
  avatar: "https://twitter.com/brunoskrebs/profile_image?size=original"
design:
  bg_color: "#4A4A4A"
  image: https://cdn.auth0.com/blog/python-restful/logo.png
tags:
- python
- flask
- sqlalchemy
- angular
- typescript
- auth0
related:
- 2017-09-28-developing-restful-apis-with-python-and-flask
- 2017-11-09-sqlalchemy-orm-tutorial-for-python-developers
---

**TL;DR:** In this series, you will learn how to create modern web applications with Python, Flask, and Angular. You will use this stack to build a SPA and a backend API to expose exams and questions so users can test their knowledge regarding different technologies. [In this GitHub repository](https://github.com/auth0-blog/online-exam/), you can find the final code created throughout the first part of the series.

---

## What You Will Build

In this series, you will use Python, Flask, and Angular to build a web application based on a modern architecture. With Angular, you will build a SPA (Single Page App) that allows users to browse through exams and questions. These users, when authenticated, will be able to test their knowledge regarding a specific topic by choosing one of the multiple choices that a question exposes. Then, when your users submit their answers, your backend will check if they are right or wrong, record the result, and send back this result to users.

As you are looking forward to building a modern web application, you will use Auth0 as [the identity management system of your app](https://auth0.com/learn/cloud-identity-access-management/). You will also persist all exams, questions, alternatives, and results on a database.

## Why Python, Flask, and Angular

[As StackOverflow recently analyzed](https://stackoverflow.blog/2017/09/06/incredible-growth-python/), Python is one of the fastest-growing programming languages, having surpassed even Java on the number of questions asked on the platform. Besides that, the language is also showing mass adoption on GitHub. On this platform, Python occupied [the second position on the number of pull requests opened in 2017](https://octoverse.github.com/).

When it comes to developing web applications with Python, you will have to choose between two popular frameworks: [Django](https://github.com/django/django) or [Flask](https://github.com/pallets/flask). Django is more mature and a little bit more popular than Flask. However, Flask has its strengths too. From the beginning, Flask was built to be scalable and simple to start with. Applications built with Flask are clearly lighter when compared to Django counterparts. As such, Python developers usually refer to Flask as a microframework.

For the frontend application, you will use Angular as this is one of the most popular frameworks around. To learn about advantages of this framework, [you can check this nice page on Rangle.io](https://angular-2-training-book.rangle.io/handout/why_angular_2.html). As stated by this page, Angular provides developers with the tools needed to build and structure large-scale JavaScript applications. Besides that, Angular has some big advantages over some alternatives. For example, Angular is built and supported by Google engineers. Alongside with these engineers, there are a huge community ready to help you with issues when the time comes.

As you can see, by choosing Python, Flask, and Angular to build web applications, you can rest assured that you will always be able to rely on great and thriving communities to support you.

{% include tweet_quote.html quote_text="Python, Flask, and Angular form a great stack to build modern web applications." %}

## Dependencies

Now that you learned why Python, Flask, and Angular form a great stack to build modern web applications, you are ready to install the local dependencies. This section is divided into two subsections to highlight what are the environment dependencies from the backend and from the frontend perspectives.

### Backend Dependencies

To start with, you will need an up to date version of Python 3. If you don't have Python 3 available on your development machine, please, [browse to the Python download page and install it](https://www.python.org/downloads/).

After installing Python, you will have to install the [`pipenv`](https://github.com/pypa/pipenv) tool. This tool aims on bringing the best of all packaging worlds (`bundler`, `composer`, `npm`, etc.) to Python developers. Also, this tool is a firstâ€“class citizen on Windows. So, if you are still stuck to this operating system, don't worry, you are covered.

To install `pipenv`, simply open a terminal and type the following command:



Python and `pipenv` together are enough to start developing your Flask application. However, as you want to persist transactional data, you still need to choose and configure a database engine. To make your life easier, you will use SQLAlchemy to persist and retrive data from the chosen engine. If you don't have experience with SQLAlchemy, please, check [this nice introductory article on the subject](https://auth0.com/blog/sqlalchemy-orm-tutorial-for-python-developers/). There, you will learn that by using the SQLAlchemy ORM (Object Relational Mapping) extension, you will be able to easily connect and use any major SQL database engine (e.g. MySQL, PostgreSQL, SQL Server, etc).

If you don't have a database available on your machine, one great way to proceed is to use Docker to spam a new one:



Of course, to run the command above, you will need to [have Docker installed locally](https://docs.docker.com/install/).

### Frontend Dependencies

As you are going to use Angular to create your frontend application, you will need [Node.js](https://nodejs.org/en/) and [NPM](https://www.npmjs.com/) installed on your machine. You can install both tools simultaneously by downloading and executing an installer (choose one based on your operating system) from [the Node.js download page](https://nodejs.org/en/download/). Another alternative is to use a tool like [NVM](https://github.com/creationix/nvm) to manage multiple active `node` versions. On a development machine, this is probably the best option.

Whichever installation method you choose, make sure you are using an up to date version of Node.js (i.e. `>= 8`).

After properly installing Node.js and NPM, you can use the `npm` command to install [the Angular CLI tool](https://github.com/angular/angular-cli). You will use this CLI (Command Line Interface) to bootstrap the frontend app, start a development server, and [to create Angular `components`, `services`, etc](https://github.com/angular/angular-cli#generating-components-directives-pipes-and-services).

Use the following command to install the Angular CLI:



## Bootstrapping the Python Application

Now that you have taken care off the environment dependencies, you can focus on developing your application. For starters, you can create a directory to hold all the frontend and the backend source code of your app. Also, you will probably want to commit everything to a Git repository to guarantee that your progress is saved. Therefore, use the following commands to start structuring your app:



After that, you will want a directory specifically created to your Flask backend application:



Then, you will want to use `pipenv` to create a virtual environemnt. If you don't know why you need a virtual environment, [check out this great article written by the author of `pipenv`](https://www.kennethreitz.org/essays/a-better-pip-workflow).



As you are using Git to backup your code, you will probably want to ignore some files. To do this, create a file called `.gitignore` in the project root directory and copy [the rules from this URL](https://raw.githubusercontent.com/auth0-blog/online-exam/master/.gitignore) into it.

### Managing Entities with SQLAlchemy ORM

With your virtual environment set up, you can start developing the features of your application. A good place to start is to define entities and to configure SQLAlchemy to persist and retrieve instances of these entities. As such, you will use `pipenv` to install the `sqlalchemy` package and a driver to connect to your database. If you are using PostgreSQL, you can use the `psycopg2-binary` driver alongside with SQLAlchemy. If you are using another database engine, please, [check this page to choose a good driver](http://docs.sqlalchemy.org/en/latest/core/engines.html#supported-databases).

The following command shows how to use `pipenv` to install `sqlalchemy` and the `psycopg2-binary` driver:



After installing SQLAlchemy and a driver to connect to the database, you can start creating your entities. To do so, use the following commands to create a module called `entities` inside another module called `src`:



The first two `touch` commands above simply create empty `__init__.py` files to mark both directories as Python modules. The last `touch` command creates the file that will hold a class called `Entity`. You will use this class as the superclass to all your entities. This will be useful to avoid having to repeat some boilerplate code to connect to the database and to define some common properties (e.g. `id` and `created_at`):



Then, after defining the `Entity` class, you can create a file called `exam.py` to represent your first entity:



On this file, insert the following code:



Here, you are defining a class called `Exam` that inherits from `Entity` and from `Base`. This entity contains, besides the properties defided by its superclasses, two properties: `title` and `description`. Besides that, this class also defines that instances of it must be persisted to and retrieved from a table called `exams`.

Having the `Exam` and `Entity` classes properly defined, you can create a script called `main.py` in the `src` directory to test if they are really connecting to the database:



Inside this script, you can add the following code:



As you can see, the code in this script is quite simple. Here is a list that summarizes what it does:

- It starts by importing `Session`, `engine`, and `Base` from the `.entities.entity` module.
- Then, it imports the `Exam` class from the `.entities.exam` module.
- Then, it genereates (if needed) the database schema.
- After generating the schema, it queries all instances of `Exam`.
- Then, if there are no exams on the database, it creates a new one and queries all instances of the `Exam` class again.
- Lastly, it prints the exams retrieved from the database.

To run this script, you will have to activate the virtual environment (created by `pipenv`) then use `python` to trigger the `src.main` module:



If everything works as expected, your module will create an instance of `Exam`, persist to the database, and print its details on the terminal.

![SQLAlchemy ORM querying a PostgreSQL database](https://cdn.auth0.com/blog/flask-angular/sqlalchemy-orm.png)

By the way, this might be a good time to save your progress:



### Managing HTTP Requests with Flask

Now that your app is connected to a database, it's time to transform it into a Flask web application. To do so, the first thing you will need is to install Flask. Besides Flask, you will also need to install `marshmallow` to handle serialization and deserialization of JSON objects. To install both dependencies, issue the following command in the `backend` directory:



After that, you will need to update the `./src/entities/exam.py` file as follows:



In the new version of this file, you are using the `Schema` class of `marshmallow` to define a new class called `ExamSchema`. You will use this class to transform instances of `Exam` into JSON objects.

After defining `ExamSchema`, you can refactor the `./src/main.py` file to expose two endpoints:



This file now creates a Flask application, based on SQLAlchemy and PostgreSQL, that is capable of accepting `POST` requests to create new instances of `exam` and capable of accepting `GET` requests to serialize these instances as a JSON array.

Now, to facilitate running this application, you can create a script called `bootstrap.sh` in the `backend` directory with the following code:



This script does three things:

1. it sets `./src/main.py` as the value of the `FLASK_APP` environment variable (this is needed by the last command);
2. it activates the virtual environment;
3. and it runs `flask` listening on all interfaces (`-h 0.0.0.0`).

Then, to test everything, you can use the following commands:



The first command on the snippet above transforms the `bootstrap.sh` script into an executable file. After that, it runs this script in the backend so you can keep using the same terminal. When the Flask application is up and running, you can use the two `curl` commands to interact with it. The first one issues `POST` requests to create new exams and the second one lists all exams persisted on the database.

![Flask application and SQLAlchemy ORM integrated.](https://cdn.auth0.com/blog/flask-angular/sqlalchemy-flask-integration.png)

Besides using `curl`, you can also fetch exams by browsing to [`http://0.0.0.0:5000/exams`](http://0.0.0.0:5000/exams).

You have made some good progress. So, it's better to save everything:



### Handling CORS on Flask Apps

As your Flask app will receive requests from a SPA, you will need to [allow CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) on it. If you don't do so, most browsers will block requests to your API because the backend does not explicitly allow *Cross-Origin Resource Sharing* (CORS).

Luckily, there is a Flask module called `flask-cors` that is easy to configure. So, to install this module, issue the following command in your `backend` directory:



Then, update the `main.py` file to take advantage of this module:



Without any further configuration, `flask-cors` allows CORS for all domains on all routes. During the development process, this configuration will be enough. However, in the future, you will probably want to be more restrictive. When the day comes, [check the official documentation of the `flask-cors` module](http://flask-cors.readthedocs.io/en/latest/#resource-specific-cors) to learn how to tweak these settings.

Now, before switching to Angular, you can save your progress and leave your Flask application up and running:



## Bootstrapping the Angular Application

To create your Angular application, you will use the `ng` tool that Angular CLI made available. So, move back to the project root directory and issue `ng new frontend`. This will create the basic structure of an Angular app. The following snippet summarizes the commands to create your app and to commit it untouched to you Git repository:



### Consuming Flask Endpoints with Angular

After creating your Angular app, the next thing you will need is to create a file called `env.ts` inside the `./frontend/src/app` directory with the following code:



For now, this TypeScript module simply exports a single constant (`API_URL`) that references your Flask backend application running locally. In the third part of this series, you will enhance this module to define different `API_URL` values depending on the environment.

Now, you can create a new directory called `exams` inside `./frontend/src/app` to hold files related to this entity. In this directory, you will create two files: `exam.model.ts` and `exams-api.service.ts`. The first file (`exam.model.ts`) will have a TypeScript class to represent exams:



The second file, `exams-api.service.ts`, will create a service that uses `HttpClient` to fetch exams from your Flask backend application:



As this service depends on `HttpClient`, you will need to import `HttpClientModule` from Angular in your `AppModule` declaration. Besides that, you will have to register `ExamsApiService` as a `provider`. So, open the `./frontend/src/app/app.module.ts` file and replace its contents with this:



Now, you will have to update the `./frontend/src/app/app.component.ts` file to use your new service to fetch data from your Flask app:



Lastly, you will have to update its template (`app.component.html`) to show the exams fetched:



With all these changes in place, you can run your Angular application (run `ng serve` on the `frontend` directory) to check if everything is working as expected. After Angular finishes compiling your app, you can browse to [`http://localhost:4200`](http://localhost:4200). On this URL, you will see a page similar to this:

![Using Angular to fetch data from a Flask application](https://cdn.auth0.com/blog/flask-angular/fetching-data.png)

This wraps up the first part of the series. Therefore, before moving on to the next parts, don't forget to save your progress:



{% include tweet_quote.html quote_text="Developing web applications with Angular and Flask is easy!" %}

## Conclusion and Next Steps

In the first part of this series, you used `pipenv` to bootstrap a Flask backend API. After that, you used SQLAlchemy ORM to integrate your Flask app with a database. Then, you installed and ran Angular CLI to create a new Angular SPA . In the end, you made your SPA fetch exams from the backend to show to visitors. These features together pave the way to create an application that relies on Flask and Angular to deliver a modern user experience.

In the next article, you will learn how modern web apps manage identity and you will enhance both your backend and your frontend apps to include more features. Stay tuned!
